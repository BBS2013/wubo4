# 常见的$命令

$0    脚本启动名(包括路径)
**$n**    第n个参数,n=1,2,…9
$*    所有参数列表(不包括脚本本身)
$@   所有参数列表(独立字符串)
$#    参数个数(不包括脚本本身)
$$    当前程式的PID
$!    执行上一个指令的PID

$?    执行上一个指令的返回值







# 子进程继承父进程

- 用户号UIDs和用户组号GIDs      
- 环境Environment      
- 堆栈      
- 共享内存      
- 打开文件的描述符      
- 执行时关闭（Close-on-exec）标志      
- 信号（Signal）控制设定      
- 进程组号      
- 当前工作目录      
- 根目录      
- 文件方式创建屏蔽字      
- 资源限制      
- 控制终端    

子进程独有

- 进程号PID      
- 不同的父进程号      
- 自己的文件描述符和目录流的拷贝      
- 子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）      
- 不继承异步输入和输出    

父进程和子进程拥有独立的地址空间和PID参数。

子进程从父进程继承了用户号和用户组号，用户信息，目录信息，环境（表），打开的文件描述符，堆栈，（共享）内存等。  

经过fork()以后，父进程和子进程拥有相同内容的代码段、数据段和用户堆栈，就像父进程把自己克隆了一遍。事实上，父进程只复制了自己的PCB块。而代码段，数据段和用户堆栈内存空间并没有复制一份，而是与子进程共享。只有当子进程在运行中出现写操作时，才会产生中断，并为子进程分配内存空间。由于父进程的PCB和子进程的一样，所以在PCB中断中所记录的父进程占有的资源，也是与子进程共享使用的。这里的“共享”一词意味着“竞争”